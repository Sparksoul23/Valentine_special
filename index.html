<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aditi Will You Be My Valentine?</title>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Poppins:wght@400;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary-color: #ff4d6d;
            --secondary-color: #ff8fa3;
            --bg-color: #fff0f3;
            --text-color: #590d22;
            --button-shadow: rgba(255, 77, 109, 0.4);
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: var(--bg-color);
            background-image:
                radial-gradient(circle at 10% 20%, rgba(255, 77, 109, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(255, 143, 163, 0.1) 0%, transparent 20%);
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            /* Prevent scrollbars when button moves */
            position: relative;
        }

        .container {
            text-align: center;
            z-index: 10;
        }

        h1 {
            font-family: 'Pacifico', cursive;
            font-size: 3.5rem;
            color: var(--text-color);
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            animation: pulse 2s infinite;
        }

        .buttons {
            display: flex;
            gap: 2rem;
            justify-content: center;
            align-items: center;
            position: relative;
            min-height: 80px;
            /* Space for buttons */
        }

        button {
            padding: 1rem 2.5rem;
            font-size: 1.2rem;
            font-weight: 600;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Poppins', sans-serif;
        }

        #yesBtn {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 4px 15px var(--button-shadow);
        }

        #yesBtn:hover {
            transform: scale(1.1);
            background-color: #ff3355;
            box-shadow: 0 6px 20px var(--button-shadow);
        }

        #noBtn {
            background-color: white;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            /* 'position: absolute' will be applied via JS for movement, 
               but initially we can keep it static or use relative. 
               Let's start static so it aligns nicely, then switch to absolute on first hover. */
        }

        /* Modal / Success Message */
        #success-message {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 3rem;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(255, 77, 109, 0.3);
            text-align: center;
            z-index: 100;
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #success-message h2 {
            font-family: 'Pacifico', cursive;
            color: var(--primary-color);
            font-size: 2.5rem;
            margin: 0 0 1rem 0;
        }

        #success-message p {
            font-size: 1.2rem;
            color: var(--text-color);
        }

        .success-gif {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin-top: 1rem;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        /* Animations */
        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        /* Confetti Canvas */
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 2.5rem;
                padding: 0 1rem;
            }

            button {
                padding: 0.8rem 2rem;
                font-size: 1rem;
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <h1> Aditi Will You Be My Valentine?</h1>
        <div class="buttons">
            <button id="yesBtn">Yes ‚ù§Ô∏è</button>
            <button id="noBtn">No üò¢</button>
        </div>
    </div>

    <!-- Hidden Success Message -->
    <div id="success-message">
        <h2>Yay!‚ù§Ô∏è</h2>
        <p>Best Valentine Ever!</p>
        <img src="gif.29" alt="Celebration" class="success-gif">
    </div>

    <canvas id="confetti-canvas"></canvas>

    <script>
        const yesBtn = document.getElementById('yesBtn');
        const noBtn = document.getElementById('noBtn');
        const successMessage = document.getElementById('success-message');
        const container = document.querySelector('.container');

        // --- STATE MANAGEMENT ---
        function showSuccess() {
            container.style.opacity = '0';
            container.style.transition = 'opacity 0.5s';
            noBtn.style.display = 'none';

            setTimeout(() => {
                successMessage.style.display = 'block';
                startConfetti();
            }, 200);
        }

        function resetPage() {
            container.style.opacity = '1';
            noBtn.style.display = 'inline-block'; // Restore display
            // Reset position if it was moved
            noBtn.style.position = '';
            noBtn.style.left = '';
            noBtn.style.top = '';

            successMessage.style.display = 'none';
            stopConfetti();
        }

        // Handle Browser Back Button
        window.addEventListener('popstate', (event) => {
            if (event.state && event.state.view === 'success') {
                showSuccess();
            } else {
                resetPage();
            }
        });

        // Handle BFcache (when returning to page via Back button from another site)
        window.addEventListener('pageshow', (event) => {
            if (event.persisted) {
                resetPage(); // Force reset if loaded from cache
            }
        });

        // --- NO BUTTON LOGIC ---

        let isMoving = false;

        const moveButton = () => {
            if (isMoving) return;

            // Set position to absolute if it isn't already (on first interaction)
            if (noBtn.style.position !== 'fixed') {
                noBtn.style.position = 'fixed';
            }

            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Button dimensions
            const btnWidth = noBtn.offsetWidth;
            const btnHeight = noBtn.offsetHeight;

            // Calculate safe area (padding from edges)
            const padding = 20;

            // Generate random position
            // Ensure it does not go off screen
            const maxLeft = viewportWidth - btnWidth - padding;
            const maxTop = viewportHeight - btnHeight - padding;

            const randomLeft = Math.max(padding, Math.floor(Math.random() * maxLeft));
            const randomTop = Math.max(padding, Math.floor(Math.random() * maxTop));

            // Smooth transition
            noBtn.style.transition = "all 0.3s ease-out"; // "Anti-gravity" feel with ease-out

            // Apply new position
            noBtn.style.left = randomLeft + 'px';
            noBtn.style.top = randomTop + 'px';
        };

        // Desktop: Hover
        noBtn.addEventListener('mouseover', moveButton);

        // Mobile: Tap/Touch (before click registers)
        noBtn.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent click
            moveButton();
        });

        // Fallback click just in case
        noBtn.addEventListener('click', (e) => {
            e.preventDefault();
            moveButton();
        });

        // --- YES BUTTON LOGIC ---

        yesBtn.addEventListener('click', () => {
            // Push history state so Back button works
            history.pushState({ view: 'success' }, 'Success', '#love');
            showSuccess();
        });


        // --- SIMPLE CONFETTI ENGINE (Single file, no dependencies) ---
        const canvas = document.getElementById('confetti-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        let animationId;
        let confettiInterval;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function createParticle() {
            const colors = ['#ff4d6d', '#ff8fa3', '#fff0f3', '#ffd700', '#ff0000'];
            return {
                x: Math.random() * canvas.width,
                y: -20,
                size: Math.random() * 8 + 4,
                color: colors[Math.floor(Math.random() * colors.length)],
                speedY: Math.random() * 3 + 2,
                speedX: Math.random() * 4 - 2,
                rotation: Math.random() * 360,
                rotationSpeed: Math.random() * 4 - 2
            };
        }

        function startConfetti() {
            // Ensure clean start
            stopConfetti();

            // Create initial burst
            for (let i = 0; i < 100; i++) {
                particles.push(createParticle());
            }

            // Start loop
            loop(); // Start animation loop

            // Add more periodically
            confettiInterval = setInterval(() => {
                if (particles.length > 300) return; // limit particles
                particles.push(createParticle());
            }, 50);

            // Stop adding after 5 seconds but keep falling
            // setTimeout(() => clearInterval(confettiInterval), 5000); // Optional: keep running or stop
        }

        function stopConfetti() {
            clearInterval(confettiInterval);
            cancelAnimationFrame(animationId);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles = [];
        }

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            particles.forEach((p, index) => {
                p.y += p.speedY;
                p.x += p.speedX;
                p.rotation += p.rotationSpeed;

                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation * Math.PI / 180);
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                ctx.restore();

                // Remove off-screen particles
                if (p.y > canvas.height) {
                    // Reset to top to loop for a bit, OR remove
                    // loop logic: 
                    p.y = -10;
                    p.x = Math.random() * canvas.width;
                }
            });

            animationId = requestAnimationFrame(loop);
        }
    </script>
</body>


</html>
